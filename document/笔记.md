# 1. SpringSecurity框架基础

## 1.1 什么是SpringSecurity

* 作用：做**认证和授权**的

  * 认证：登录

    ![](image/图片1.png)

  * 授权：权限管理，给用户颁发权限，有些资源不能让用户看，只有有权限的人才能看

    ![](image/图片2.png)

    ![](image/图片3.png)

* 官网：https://spring.io/projects/spring-security

  * Spring Security是一个功能强大且高度可定制的**身份认证（登录）和访问控制（权限管理）框架**。它是保护基于 Spring 的应用程序的事实上的标准。(Shiro框架)
  * Spring Security是一个致力于为Java 应用程序提供身份认证和授权的框架。像所有Spring项目一样，Spring Security的真正强大之处在于它可以非常轻松地扩展来满足自定义需求.



## 1.2 SpringSecurity快速上手

* spring security现在开发时不会采用spring进行开发，而是采用spring boot进行开发；spring security本身也是在spring boot流行之后才被大量使用；spring boot流行 2017年。

* 依赖

  ```xml
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-security</artifactId>
  </dependency>
  ```

* Controller类

  ```java
  @RestController
  public class UserController {
      @RequestMapping("/hello")
      public String hello(){
          return "Hello, Spring Security!";
      }
  }
  ```

* 访问：http://localhost:8080/hello

  项目中一旦添加了spring security的jar包依赖，那么所有的controller接口路径访问时都会被spring security拦截，它会检查你是否登录，如果未登录，就会跳转到它的一个默认登录页，如果登录了，那么可以直接访问controller的路径；



## 1.3 SpringSecurity基本原理分析

http://localhost:8080/hello --> http://localhost:8080/login 

1. 采用重定向跳转到登录页面；

2. Spring Security采用16个Filter进行过滤拦截；（基于session）

   ![](image/16个拦截器.jpg)

   * 入口：`FilterChainProxy`

   * 代码: `doFilterInternal`方法

     ```java
     List<Filter> filters = this.getFilters((HttpServletRequest) firewallRequest);
     ```

   * 生成登录的页面：`DefaultLoginPageGeneratingFilter`

   * 生成退出的页面：`DefaultLogoutPageGeneratingFilter`

   * 登录跳转地址是： /login (这是Spring Security框架提供的，不是我们写的)

   * 退出跳转地址是： /logout (这是Spring Security框架提供的，不是我们写的)

   * 默认情况下，用户名是user，密码是临时生成的uuid（默认密码会在启动SpringBoot应用时输出到控制台）；（来自SecurityProperties类）

   * 可以修改默认的用户名和密码，在配置文件application.properties中配置

     ```properties
     #自己指定登录的用户名和密码
     spring.security.user.name=cat
     spring.security.user.password=aaa111
     ```







# 2. SpringSecurity框架登录认证

## 2.1 基于数据库查询登录

* Controller类

  ```java
  @RestController
  public class UserController {
      @RequestMapping("/")
      public String index(){
          return "Welcome to Spring Security";
      }
  }
  ```

* Service接口

  ```java
  // 我们处理登录的service接口，需要集成SpringSecurity框架的UserDetailsService接口
  public interface UserService extends UserDetailsService {
  }
  ```

* Service实现类

  ```java
  @Service
  public class UserServiceImpl implements UserService {
      @Autowired
      private TUserMapper tUserMapper;
  
      /**
       * 这个方法是在UserDetailsService接口中定义的
       * 该方法会在SpringSecurity框架登录的时候登录
       * @param username
       * @return
       * @throws UsernameNotFoundException
       */
      @Override
      public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
          // 查询数据库，查询页面传递的用户名是否在数据库中存在
          TUser tUser = tUserMapper.selectByLogiznAct(username);
          if (tUser == null) {
              // UsernameNotFoundException异常是SpringSecurity框架提供的
              throw new UsernameNotFoundException("登录账号不存在");
          }
  
          // 注意：以下的User类是SpringSecurity框架中的User类
          // 该User类实现了UserDetails接口
          UserDetails userDetails = User.builder()
                  .username(tUser.getLoginAct())
                  .password(tUser.getLoginPwd())
                  .authorities(AuthorityUtils.NO_AUTHORITIES) // 设置权限是空
                  .build();
          // 把UserDetails（User）返回给框架之后，框架会采用密码加密器进行密码的比较
          return userDetails;
      }
  }
  ```

  **注意：重点是编写Service接口要继承UserDetailsService接口，Service实现类要重写loadUserByUsername方法**

* 运行时报错：

  * 老版本报错：`java.lang.IllegalArgumentException`:You have entered a password with no PasswordEncoder
  * 新版本报错：Given that there is no default password encoder configured, each password must have a password encoding prefix. Please either prefix this password with '{noop}' or set a default password encoder in `DelegatingPasswordEncoder`.

* 这是因为没有加入**密码加密器**导致的；

  ```java
  @Configuration
  public class SecurityConfig {
      @Bean
      public PasswordEncoder passwordEncoder() {
          return new BCryptPasswordEncoder();
      }
  }
  ```



## 2.2 数据库登录流程分析

1、访问http://localhost:8080/  

2、被spring security的filter过滤器拦截（里面有16个Filter）； 

3、由于没有登录过，所以spring security就跳转到登录页（登录页是框架生成的）

4、我们在登录页输入账号和密码去登录提交；（账号和密码是数据库的账号密码）

5、spring security里面的UsernamePasswordAuthenticationFilter接收账号和密码；

6、第5步的这个filter会调用loadUserByUsername(String username)方法去数据库查询用户；

7、从数据库查询到用户后，把用户组装成UserDetail对象，然后返回给SpringSecurity框架；

8、第7步返回后，再回到框架的filter里面进行用户状态的判断，用户对象中默认有4个状态字段，如果这4个状态字段的值都是true，该用户才能登录，否则就是提示用户状态不正常，不能登录的（框架中实际上只判断3个状态值，那个密码是否过期没有做判断）；

9、第7步返回后，再回到框架的filter里面进行密码的匹配，如果密码匹配上了，就登录成功，否则失败；

10、比较密码代码：

* 首先执行`UsernamePasswordAuthenticationFilter`类的`attemptAuthentication`方法

* 然后执行到`AbstractUserDetailsAuthenticationProvider`类的`authenticate`方法：

  ```java
  this.additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken)authentication);
  ```

* `additionalAuthenticationChecks`方法的核心代码

  ```java
  String presentedPassword = authentication.getCredentials().toString();
  // 调用密码加密器passwordEncoder的matches方法，传入明文密码presentedPassword和密文密码进行密码的比较
  if (!this.passwordEncoder.matches(presentedPassword, userDetails.getPassword())) {
      this.logger.debug("Failed to authenticate since password does not match stored value");
      throw new BadCredentialsException(this.messages.getMessage("AbstractUserDetailsAuthenticationProvider.badCredentials", "Bad credentials"));
  }
  ```



## 2.3 自定义登录页

* Controller

  ```java
  @Controller
  public class UserController {
      @RequestMapping("/")
      @ResponseBody
      public String index(){
          return "Welcome to Spring Security";
      }
  
      @RequestMapping("/toLogin")
      public String toLogin(){
          return "login"; // 跳转到login.html页面
      }
  }
  ```

* 准备登录页面（前后端不分离，使用thymeleaf模版技术搭建登录页面）

  * 添加依赖

  * 在resources/templates/目录下新建login.html

    ```html
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>登录</title>
    </head>
    <body>
        <form action="/user/login" method="post">
            账号：<input type="text" name="username"/><br/>
            密码：<input type="password" name="password"/><br>
            <!-- 登录页面需要有这个隐藏域 -->
            <input name="_csrf" type="hidden" th:value="${_csrf.token}">
            <input type="submit" value="登录">
        </form>
    </body>
    </html>
    ```

* SecurityConfig

  ```java
  @Configuration
  public class SecurityConfig {
      @Bean
      public PasswordEncoder passwordEncoder() {
          return new BCryptPasswordEncoder();
      }
  
      // 配置SpringSecurity框架的一些行为
      // 配置我们自己的登录页，不使用框架默认的登录页
      // 但是当配置了SecurityFilterChain这个Bean之后，SpringSecurity的某些默认行为就失效了
      // 此时需要加回来
      @Bean
      public SecurityFilterChain securityFilterChain(HttpSecurity httpSecurity) throws Exception { // 安全过滤器Bean
          // SecurityFilterChain是一个接口，DefaultSecurityFilterChain是实现类
          // 在SpringSecurity框架开发时，不是直接new DefaultSecurityFilterChain
          // return new DefaultSecurityFilterChain();
  
          // httpSecurity是Spring容器中的一个Bean，通过参数注入进来
          return httpSecurity
                  // 配置我们自己的登录页
                  .formLogin(t -> {
                      // 框架默认的接受登录提交（form表单）请求的地址是 /login
                      // 需要告诉框架表单提交的地址
                      t.loginProcessingUrl("/user/login")
                       .loginPage("/toLogin");// 定制登录页 (Thymeleaf页面)
                  })
                  // 把所有接口都会进行登录状态检查的默认行为捡回来
                  .authorizeHttpRequests(t -> {
                      t.anyRequest().authenticated(); // 任何请求都需要认证
                  })
                  .build();
      }
  }
  ```

* 启动程序，访问localhost:8080/ ，请求失败，重定向次数过多，原因如下：

  * 浏览器输入地址http://localhost:8080/，此时没登录，需要跳转到登录页面，即请求重定向到"/toLogin"，此时框架检查还是未登录状态，继续跳转登录页面，.......，重定向陷入死循环。

* 因此"/toLogin"请求不需要拦截

  ```java
  @Bean
  public SecurityFilterChain securityFilterChain(HttpSecurity httpSecurity) throws Exception {
      return httpSecurity
              .formLogin(t -> {
                  t.loginProcessingUrl("/user/login") // 表单接收地址
                   .loginPage("/toLogin");// 定制登录页 (Thymeleaf页面)
              })
              .authorizeHttpRequests(t -> {
                  t.requestMatchers("/toLogin").permitAll() // 特殊情况，允许不登录就可以访问
                   .anyRequest().authenticated(); // 任何请求都需要认证
              })
              .build();
  }
  ```

  

